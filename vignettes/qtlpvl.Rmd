<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Introduction to qtlpvl}
-->

```{r, echo = FALSE, message = FALSE}
library(qtlpvl)
knitr::opts_chunk$set(
  comment = "#>",
  error = FALSE,
  tidy = FALSE)
```

# Introduction to qtlpvl

This package is focusing on QTL mapping with multiple traits and
testing of pleiotrophy vs. close linkage when multiple traits mapped
near each other, with the case of trans-eQTL hotspot in mind
particularly. We provide both exploration plot functions and formal
statistical tests aimning at dissecting trans-eQTL hotspots.

## Data

We use data `listeria` from `R\qtl` as an example. We only used the
genotypes of this F$_2$ population and generated the phenotypes from
normal distribution. Assume the first QTL have additive effect only
and the second QTL have dominant effect --individuals with genotype 2
and 3 are grouped together to have the same shift in mean. The first 5
traits are controlled by the first QTL and the other 5 trait of the
total 10 are controlled by the second QTL with negative, bigger
effect. The 10 phenotypes are generated with these QTL effects plus
independent noise generated from standard normal distribution. Assume
that these traits are measurements of gene expressions and we randomly
generate fake positions for these genes. All data generated are stored
in the package and we can load the data by:

```{r}
data(fake.phenos)
```

We could first look at the single triat analysis result.  For each
trait, we plot its LOD score versus QTL position when the LOD is
bigger than a threshold (default value is 3).

```{r,plotLOD}
plotLOD(Y=Y, cross=listeria, chr=chr)
```

## joint mapping: `scanone.mvn`

Having the cross object `listeria` and phenotype trait matrix `Y`
loaded, we can first run a joint mapping with `scanone.mvn`, which
assumes multivariate normal model. `chr` is set to be "1", which
indicates the mapping is only on chromosome 1. Function `scanone.mvn`
has two more parameters `addcovar` and `intcovar`, they could be used
to control for additive and interactive covariates when
needed. `intcovar` will also be used as additive covariates during
mapping, and there is no need to manually add them into `addcovar` by
the user.

The result of joint mapping is a data frame with class `scanone`, we
could apply (S3) method `summary` and `plot` to look at the result.

```{r}
out <- scanone.mvn(cross=listeria, Y=Y, chr=chr)
summary(out)
plot(out)
```

We could see the QTL is at `r sprintf("%.2f",summary(out)$pos)` cM
with LOD score `r sprintf("%.2f",summary(out)$lod)`. It is more
towards the second QTL since the second QTL has a bigger effect than
the first.

## Statistical Testing
### test of 1 vs 2 QTL: `testpleio.1vs2`

We test the hypothesis of:
* $H_0$: There is only one QTL affecting all the phenotypes;
* $H_1$: There are two QTLs, each affecting one of the two phenotype
  groups.

We assume the traits follow multivariate normal distribution and
perform joint mapping to locate the single-QTL under the null
hypothesis that there is one pleiotrophic QTL affecting all the
traits; we then run single trait analysis on each trait and find the
trait-specific QTL, sort the traits by their QTL position and search
for the best separation of the traits into two groups, where the first
group (contains the first several traits) is controlled by the right
QTL and the second group (contains the rest traits) is controlled by
the left QTL. The LOD score of this two-QTL model is then subtracted
by the LOD score of the single-QTL model to arrived at the final test
statistic, $\text{LOD}_{2v1}$.

To get the null distribution of the statistics, we have two methods:
* parametric bootstrap: generate data from the parameters estimated
  under the null hypothesis
* stratified permutation: randomly permute the genotype data versus
  phenotype data with in each QTL genotype group,

we repeat the whole procedure on data from either method and save the
test statistics. The P-value is calculated from this empirical
distribution.

Function `testpleio.1vs2` is used to do this test. Input parameters:
* cross: An object of class `cross`.
* Y: matrix of multiple traits, with samples in the row, traits in the
  column.
* chr: One character strings referring to chromosome of interest by
  name.
* region.l, region.r: left and right bound for the interval of
  interest.
* int.method: can have value of `bayes` or `1.5lod`, method to
  calculated the interval of interest if `region.l` and `region.r` is
  not specified.
* search.method: searching method for two-QTL model, can have value of
  `fast` or `complete`, default is `fast`.
* RandomStart: when search.method is `fast`, use random starting point
  for the two-QTL model or not, default is `TRUE`.
* RandomCut: use random cutting or not when there are traits mapped to
  the same location. default is `FALSE`, triats mapped to the same
  location will be bound together.
* simu.method: `parametric` or `permutation` method for
  simulations. default is `parametric`.
* n.simu: number of simulations for p-value.
* tol: Tolerance value for the `qr` decomposition in `lm` fitting.
* addcovar, intcovar: Additive and interactive covariates to control
  for when mapping.

This function will return a list with class `testpleio.1vs2`, similar
to `scanone`, we could apply (S3) method `summary` and `plot` to look
at the result. In the summary, we could see the position and LOD score
for the single QTL and best two QTL model, as well as test statistics
$\text{LOD}_{2v1}$ and its P-value.

```{r}
obj <- testpleio.1vs2(cross=listeria, Y=Y, chr=chr, n.simu=10,
                      region.l=60, region.r=90, search.method="complete")
summary(obj)
plot(obj)
```

The above figure shows the joint mapping result in black and profile
for each of the two QTLs under $H_1$:

* red line: $L_1(\lambda_1) = \max_{\lambda_2} LOD2(\lambda_1,
  \lambda_2)$
* blue line: $L_2(\lambda_2) = \max_{\lambda_1} LOD2(\lambda_1,
  \lambda_2)$

Triangles indicate the position of the QTLs and solid points indicate
QTL positions and LODs from single trait mapping.

We could also use `plottrace` to see how $\text{LOD}_{2v1}$ changes
when we move the cut-point of the left versus right group. There are 7
possible QTL positions from the above plot (result of single trait
mapping), thus we have 6 possible ways of grouping these positions
into the left versus right group. The 6 open dot indict the cut and
their $\text{LOD}_{2v1}$.  Thus when the first 5 traits and the last 5
traits are grouped separately, the $\text{LOD}_{2v1}$ is the biggest,
it is our best two QTL model.  This figure could be used as a
diagnostic figure, to see if our best two QTL model is better than the
rest of all the possible models.

```{r}
plottrace(obj)
```

### test of 1 vs p QTL: `testpleio.1vsp`

We could also test the hypothesis of:
* $H_0$: There is only one QTL affecting all the phenotypes;
* $H_1$: There are p QTLs, each affecting one of the phenotypes, i.e.,
  each phenotype is allowed to has its own QTL.

This function has much less parameters than the previous one. We have
`cross`, `Y`, `chr`, `addcovar`, `intcovar` and `n.simu`, the usage is
same as before.  This function will return a list with class
`testpleio.1vsp`, similar to `scanone` and `testpleio.1vs2`, we could
apply (S3) method `summary` and `plot` to look at the result.  In the
summary, we could see the position and LOD score for the single QTL
and p QTL model, as well as test statistics $\text{LOD}_{2v1}$ and its
P-value.

```{r}
obj2 <- testpleio.1vsp(cross=listeria, Y=Y, chr=chr, n.simu=10)
summary(obj2)
plot(obj2)
```

## Exploration plots
### plot Genetic Pattern: `plotGenetpattern`

Function `plotGenetpattern` takes two kinds of input parameters:
* a phenotype matrix `Y` and a genotype vector `genotype`, the later
  should be genotype of the common QTL in most suspicious.
* a phenotype matrix `Y` and a cross object `cross` and chromosome
  number `chr`. This is used when there is no certainty of a single
  QTL for all traits and thus each trait is mapped separately and its
  own QTL genotype is used.

QTL additive effect is defined as a=(RR-BB)/2, QTL dominant effect is
defined as d=BR-(BB+RR)/2, when plotted against each other, traits
with pure additive effects are near the x-axis ($d=0$) and traits with
dominant effects are along the diagonals, $d=a$ (BR=RR) and $d=-a$
(BR=BB).

```{r, fig.width=12, fig.height=6}
par(mfrow=c(1,2))
qtlpos <- max(out)$pos
m <- find.pseudomarker(listeria, chr, qtlpos, "prob", addchr=FALSE)
qtlgeno <- apply(listeria$geno[[chr]]$prob[,m,], 1, which.max)

plotGenetpattern(Y=Y, genotype=qtlgeno, main="by common QTL genotype")
plotGenetpattern(Y=Y, cross=listeria, chr=chr,
                 main="by individual QTL genotype")
```

We can tell from both plots the there are two different genetic
patterns, thus possible two different QTLs, even if they are closely
linked.

### plot LOD score with sign: `plotLODsign`

Using the same data, we could also display the direction of the QTL
effect with `plotLODsign`.  Function `plotLODsign` takes input
`cross`, `Y` and `chr`, as well as `addcovar` and `intcovar`, all has
been introduced above.

For each trait, the QTL effect direction is used as the sign of the
LOD score. We first run single trait mapping for LOD scores and QTL
positions, then we use `argmax.geno` to impute QTL genotypes and
calculate mean for each of the 3 genotype group. We define the
direction positive when the mean of the first group is bigger than the
mean of the third group, and negative if not. Only traits with LOD
score bigger than a threshold will be displayed, the default value of
the threshold `LOD.threshold` is set as 3.

```{r}
plotLODsign(Y=Y, cross=listeria, chr=chr)
```

We indicate the positions of all the genotyped markers with little
ticks at the x-axis. We can pass these values to parameter `map` or
let the function handle it by pulling this information from the
`cross` object at a fixed `chr`.

If we already have mapped the traits (which in most case is done
previousely), we can pass the signed LOD scores and their mapped
positions to `LODsign` and `maxPOS` respectively. This option speed up
the procedure by skiping mapping the triats redundantly. The use of
this feature will be shown at the last section.

### Linear discriminant plot: `plottrans.LDA`

In this method we group individuals into two groups by whether there
is a recombiantion event in the region. For individuals with no
recombinantion events, we will know there eQTL genotype since they
have the same genotype in the region, we then apply linear
discriminant analysis to the traits with the eQTL genotype as `label`
and plot the first 2 linear discriminants, shown as three distince
clusters. We then calculate the linear discriminants for the other
group with recombinantion event in the region by using the same
coffecients, and add them to the plot. If the recombinant individuals
fall within the clusters defined by the non-recombinants, this is
consistent with there being a single eQTL. If, on the other hand, the
recombinants look distinctly different from the non-recombinants, then
there might be more than one eQTL.

In the following code, we first find which inidviduals have no
recombinant event, and then call the function `plottrans.LDA` with
phenotype matrix `Y`, QTL genotype `qtlgeno` and nonrecombinant IDs
`nonrecomb`.

```{r}
out <- out[out$chr==chr, ]
m <- which(out$pos >= qtlpos-5 & out$pos <= qtlpos+5)
g <- apply(listeria$geno[[chr]]$prob[,m,], 1:2, which.max)
nonrecomb <- which(sapply(apply(g, 1, unique), length) == 1)
names(nonrecomb) <- rownames(Y)[nonrecomb]

plottrans.LDA(Y, qtlgeno, nonrecomb)
```

In the above plot each point is a individual colored by its QTL
genotype if it is non-recombinant or yellow if it has recombiant.

## Analysis as trans-eQTL hotspot with probepos

Lastely, we will show the whole procedure recommended for analysis of
expression data.  We start by mapping each phenotype individually,
then count the number of eQTLs in windows of 10~cM, when there seems
to be a trans-eQTL hotspot, we can build a object `transband` by
`make.transbands`, the object contains basic information of the
transband: chromosome and postion of the transband, number of eQTLs in
the transband, and estimate of QTL position and LOD score under
multivariate assumption; it also contians all the information needed
for the exploration plots: QTL LOD scores and positions, additive and
dominance effects, QTL geneotypes, and non-recombinant IDs. It is
easier to extract these infomations from this object and run all the
statistical test and exploration plots in a batch.

```{r, fig.width=12, fig.height=8}
library(qtlpvl)
data(fake.phenos)
phenoname <- colnames(Y)
listeria$pheno <- data.frame(listeria$pheno, Y)
out <- scanone(listeria, pheno.col=phenoname, chr=1:19)
out1 <- convert_scan1(out, phenoname, chr=1:19)

marker.info <- get.marker.info(listeria, chr)
out.count <- count.trans(out1, probepos, chr, marker.info)

par(mfrow=c(2,3))
plot(out.count, main="Count of trans-eQTL")

trans <- make.transbands(out1, probepos, cross=listeria, chr=1:19,
                         mlratio = Y, lod.thr = 5,
                         trans.cM = 5, kernal.width = 1,
                         window.cM = 10, trans.count.thr = 0,
                         regn.cM = 5)
transband <- trans[[1]]

Y <- attr(transband, "Y")
geno <- attr(transband, "geno")
nonrecomb <- attr(transband, "nonrecomb")
out <- attr(transband, "out")
map <- pull.map(listeria)
obj <- testpleio.1vs2(cross=listeria, Y=Y, chr=chr, n.simu=10,
                      region.l=60, region.r=90)

plot(obj, main="LOD profile")
plottrace(obj, main="Trace")
plotLODsign(maxPOS=out$pos, LODsign=sign(out$eff.a)*out$lod1, map=map[[chr]],
            main="Signed LOD")
plotGenetpattern(a=out$eff.a, d=out$eff.d, main="Inheritance Pattern")
plottrans.LDA(Y, geno, nonrecomb, main="LDA plot")

```


## Session Info
```{r}
sessionInfo()
```
